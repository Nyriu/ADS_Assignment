---
title: "Assignment"
author: "Tristano Munini"
date: "15/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE, error=FALSE, echo=F, show=F, include=F}
# TODO check which are needed
#library(rrecsys)
library(readr)
library(stringr)
library(tidyr)
library(dplyr)
library(igraph)
library(ggplot2)
library(ggrepel)
library(ggraph)
library(gganimate)
library(plotly)
library("RColorBrewer")

library(formattable)
## TODO add pretty images lib
```

## Introduction

TODO

## Datasets

### Downloaded

The first dataset considered is the [Steam Video Games Dataset](https://www.kaggle.com/tamber/steam-video-games).
This dataset is a list of user behaviors, with columns: user-id, game-title, behavior-name, value. The behaviors included are 'purchase' and 'play'. The value indicates the degree to which the behavior was performed. In the case of 'purchase' the value is always 1, and in the case of 'play' the value represents the number of hours the user has played the game.
```{r echo=F}
raw_data = as_tibble(
  read.csv("steam-200k.csv", header=F,
           col.names = c( "user-id","game-title", "behavior-name", "value", "unknown")
           )
  ) %>% select(-unknown)
formattable(head(raw_data))
```
```{r include=F, eval=F}
raw_data
dim(raw_data)
raw_data %>% distinct(user.id)
raw_data %>% distinct(game.title)
raw_data %>% distinct(user.id, game.title) %>% group_by(user.id) %>% count() %>%
  ggplot(aes(x=n)) +
  geom_bar()
raw_data %>% distinct(user.id, game.title) %>% group_by(user.id) %>% count() %>%
  ggplot(aes(x=n)) +
  geom_boxplot()
```


```{r include=F, eval=F}
summary(raw_data %>% distinct(user.id, game.title) %>% group_by(user.id) %>% count() %>% ungroup() %>% select(n))
e1071::skewness( raw_data %>% distinct(user.id, game.title) %>% group_by(user.id) %>% count() %>% pull(n))
```
```{r include=F, eval=F}
raw_data %>% filter(behavior.name == "play") %>% select(user.id, value) %>% group_by(user.id) %>% summarize(value=sum(value)) %>% ungroup()
summary(
  raw_data %>% filter(behavior.name == "play") %>% select(user.id, value) %>% group_by(user.id) %>% summarize(value=sum(value)) %>% ungroup()
)

# users with most games and playtime
raw_data %>% distinct(user.id, game.title, value) %>% group_by(user.id) %>%
  summarize(playtime=sum(value), games.num=n()) %>%
  ungroup() %>%
  slice_max(games.num, n=3)
raw_data %>% distinct(user.id, game.title, value) %>% group_by(user.id) %>%
  summarize(playtime=sum(value), games.num=n()) %>%
  ungroup() %>%
  slice_max(playtime, n=3)
```


The dataset contains 200k entries relative to over 12k different users and over 5k games.
The skewness of the data, equal to 10.74, is evident, with a median of 2 and a mean of 10 game purchases per user.
Also the playtime has a high variability between gamers: from users that played for less than 5 minutes, to users with thousands and thousands of hours.
The user with the highest number of games has 1552 games with a playtime of 6778 hours.
Instead the user that spent the highest number of hours playing spent 11906 hours on 433 different games.
Sadly the dataset does not contain the period in which the hours were spent.

<!-- #### 2 -->

[Steam games complete dataset](https://www.kaggle.com/trolukovich/steam-games-complete-dataset) is the second dataset used.
In this one are listed 40k games, each with a set of information about the genre, the developer, associated tags, description, and others.
For the purpose of this assignment we are interested only in a subset of the columns, for example the url to the Steam page is not useful for us.
Follows a glimpse of the data.
```{r echo=F}
raw_data_2 = as_tibble( read.csv("steam_games.csv") ) %>%
  select(name, release_date, genre, developer, publisher, everything(),
         -url, -recent_reviews, -all_reviews, -mature_content,
         -minimum_requirements, -recommended_requirements, -discount_price)

formattable(head(raw_data_2 %>% select(name, release_date, genre, developer)))
```

### Analyzed

Because I was interested in following the connections between gamers and type of games played I've created two sub datasets:
<!-- TODO add link to github? -->
*users_info.csv* is a subset of the first one, while *games_info.csv* is a subset of the second.
They were created joining the initial datasets in a way that, for now on, only games with players will be considered and only player that play games for which we actually have details.
Summing up we consider 2k games and 10k users, with over 90k user-game interactions (either "purchase" or "play").
Every users plays at least one of the 2k games and every game has at least a player.

```{r eval=F, include=F}
games_info_raw =
  raw_data %>%
  distinct(game.title) %>%
  arrange(game.title) %>%
  left_join(raw_data_2, by=c("game.title"="name")) %>%
  group_by(game.title) %>%
  slice(1)
data = raw_data %>%
  right_join(
    games_info_raw %>%
      filter(!is.na(types)) %>%
      filter(release_date != "NaN") %>%
      filter(release_date != "NA") %>%
      select(game.title),
    by = "game.title"
    )
games_info = games_info_raw %>%
  right_join(data %>% distinct(game.title), by="game.title")
#write.csv(games_info, "games_info.csv", row.names = F)
users_info =
  raw_data %>%
  right_join(data %>% select(user.id, game.title, behavior.name), by=c("user.id","game.title","behavior.name"))
#write.csv(users_info, "users_info.csv", row.names = F)
```

```{r error=F, warning=F, include=F}
games_info = read.csv("games_info.csv") %>%
  # date as date and not as char
  mutate( across(
    c(release_date),
    function(x) {
        parse_date(x, "%b %d, %Y",locale=locale("en"))
      }) )
games_info
users_info = read.csv("users_info.csv")
users_info
```



## About the users

### Type of gamers
```{r include=F}
games_prices = games_info %>%
  select(game.title, original_price) %>%
  mutate(
    price = 
      unlist( lapply(
        original_price,
        function (x) {
          y = str_remove(x, "[$]")
          tryCatch(
            as.double(y),
            error=function(z) 0,
            warning=function(z) 0
          )
        }
      )) %>% replace_na(0)
  )

users_clust_data =
  left_join(
    users_info %>%
      filter(behavior.name == "purchase") %>%
      right_join(
        games_prices %>% select(-original_price),
        by="game.title"
      ) %>%
      group_by(user.id) %>%
      summarize(titles=n(), capital=sum(price), .groups="keep") %>%
      ungroup(),
    users_info %>%
      filter(behavior.name == "play") %>%
      group_by(user.id) %>%
      summarize(hours=sum(value), .groups="keep") %>%
      ungroup(),
    by="user.id"
  ) %>%
  # Not zero but small value for log
  replace_na(list(titles=0.0001, hours=0.0001)) %>%
  mutate(capital=capital+0.0001)

users_clust_log_data =
  users_clust_data %>%
  mutate(titles = log(titles), hours = log(hours), capital=capital)

users_kmeans_3 = kmeans(users_clust_log_data, centers=3, nstart=5, iter.max = 200)
```

**TODO** tradurre ed estendere

Dal plot possiamo notare che:
1. il clustering ha piu' senso se osserviamo "default"
2. chi ha piu' ore non e' chi ha piu' giochi
3. chi ha piu' giochi e' chi ha speso piu' soldi
4. la maggior parte dei giocatori ha speso poco e ha giocato poco

![](users_animate_01.gif)

```{r echo=F, eval=F, include=F}
to_plot =
  rbind(
    cbind(
      users_clust_data %>% mutate(scale="default"),
      cluster=as.factor(users_kmeans_3$cluster)),
    cbind(
      users_clust_log_data %>% mutate(scale="log"),
      cluster=as.factor(users_kmeans_3$cluster)
    )
  ) %>%
  mutate(scale = as.factor(scale))

to_plot_particular =
  rbind(
    to_plot %>% filter(scale=="default") %>% slice_max(titles, n=2),
    to_plot %>% filter(scale=="default") %>% slice_max(hours,  n=2),
    to_plot %>% filter(scale=="default") %>% slice_max(capital,  n=2),
    to_plot %>% filter(scale=="log") %>% slice_max(titles, n=2),
    to_plot %>% filter(scale=="log") %>% slice_max(hours,  n=2),
    to_plot %>% filter(scale=="log") %>% slice_max(capital,  n=2)
  ) %>% arrange(user.id) %>%
  distinct(user.id,scale, .keep_all = T)
 
# TODO fix labels/titles
to_plot %>%
  ggplot(aes(x=titles, y=hours)) +
  geom_point(aes(alpha=capital, color=cluster)) +
  geom_label_repel(
    data=to_plot_particular,
    aes(label = user.id),
    box.padding   = 0.35, 
    point.padding = 0.35,
    segment.color = 'grey50'
    ) +
  transition_states(scale,
                    transition_length = 2,
                    state_length = 2) +
  ease_aes('cubic-in-out') +
  view_follow() +
  ggtitle('Now showing {closest_state}',
          subtitle = 'Frame {frame} of {nframes}') +
  theme_minimal()
  #theme_grey()

# TODO plot fermi dei due stati == log e == default (dopo aver fixato label etc)
```

```{r eval=F, include=F}
## Qua si puo' dire che chi spende di piu' non e' chi gioca di piu'. ANZI!
to_plot %>%
  filter(scale=="default") %>%
  ggplot(aes(x=titles, y=capital)) +
  geom_point() +
  geom_label_repel(
    data=to_plot_particular %>% filter(scale=="default"),
    aes(label = user.id),
    box.padding   = 0.35, 
    point.padding = 0.35,
    segment.color = 'grey50') #+

to_plot %>%
  filter(scale=="default") %>%
  #ggplot(aes(x=hours, y=capital)) +
  ggplot(aes(x=capital, y=hours)) +
  geom_point() +
  geom_label_repel(
    data=to_plot_particular %>% filter(scale=="default"),
    aes(label = user.id),
    box.padding   = 0.35, 
    point.padding = 0.35,
    segment.color = 'grey50') #+
```

# What about the highlited gamers
```{r include=F}
## Creare dati per pie di tempo e soldi
pie_data =
users_info %>%
  filter(behavior.name == "play") %>%
  right_join(
    rbind(
      users_clust_data %>% slice_max(titles, n=2),
      users_clust_data %>% slice_max(hours,  n=2),
      users_clust_data %>% slice_max(capital,  n=2) ) %>%
      distinct(user.id, .keep_all = T),
    by="user.id"
  ) %>%
  left_join(
    games_prices,
    by="game.title"
  ) %>%
  select(-behavior.name, -original_price) %>%
  group_by(user.id) %>%
  mutate(hours_total = sum(value)) %>%
  ungroup() %>%
  mutate(hours_perc = value/hours_total, hours=value, capital_perc=price/capital) %>%
  select(user.id, game.title, price, hours, hours_perc, capital_perc, hours_total, capital)
```


```{r}
pie_data_top =
  pie_data %>%
  group_by(user.id) %>%
  filter(hours_perc > 0.03) %>%
  arrange(desc(hours_perc)) %>%
  slice(1:6) %>% # Keep only top k played for each gamer
  ungroup()


pie_data_others = data.frame(
  user.id=
    unlist( lapply(
      setdiff(
        paste(pie_data$user.id,  pie_data$game.title, sep="$"),
        paste(pie_data_top$user.id,  pie_data_top$game.title, sep="$") ),
      
      function (x) {
        as.integer(unlist(str_split(x, "[$]"))[[1]])
      }
    )),
  game.title=
    unlist( lapply(
      setdiff(
        paste(pie_data$user.id,  pie_data$game.title, sep="$"),
        paste(pie_data_top$user.id,  pie_data_top$game.title, sep="$") ),
      function (x) {
        unlist(str_split(x, "[$]"))[[2]]
      }
    ))
  ) %>%
  left_join(pie_data, by=c("user.id","game.title")) %>%
  group_by(user.id) %>%
  summarise(
    price=sum(price),
    hours=sum(hours),
    hours_perc=sum(hours_perc),
    capital_perc=sum(capital_perc)
  ) %>%
  ungroup() %>%
  mutate(game.title="Others")

```




```{r}
to_plot =
  pie_data_top %>% add_row(pie_data_others) %>%
    arrange(user.id, desc(game.title)) %>%
    group_by(user.id) %>%
    ungroup()

dispositions = c(
  0,0,
  0,1,
  1,0,
  1,1
)

fig = plot_ly()
i = 1
for (user in (to_plot %>% distinct(user.id) %>% pull())) {
  data = to_plot %>%
    filter(user.id == user) %>% select(game.title, hours) %>%
    mutate(label = paste(game.title, paste(hours, "h", sep=""), sep="\n"))
  fig = fig %>%
    add_pie(data=data,
            labels = ~label,
            values = ~hours,
            name = user,
            domain = list(row=dispositions[[i]], column=dispositions[[i+1]]),
            title = list(title="hola"),
            textinfo='percent',
            hoverinfo='label+name'  # TODO REMOVE
            #hoverinfo='label'
    )
  i = i + 2
}
  

# TOOD better labels
fig = fig %>%
  layout(#title = "Pie Charts with Subplots",
    showlegend = F,
    grid=list(rows=2, columns=2),
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)#,
    #annotations = list(
    #  list(
    #    x = 0.05,
    #    y = 0.18,
    #    text = (to_plot %>% distinct(user.id) %>% pull())[[1]],
    #    font = list(size = 16), 
    #    showarrow = FALSE,
    #    textangle=-90
    #  ),
    #  list(
    #    x = 0.05,
    #    y = 0.75,
    #    text = (to_plot %>% distinct(user.id) %>% pull())[[2]],
    #    font = list(size = 16), 
    #    showarrow = FALSE,
    #    textangle=-90
    #  ),
    #  list(
    #    x = 0.75,
    #    y = 0.18,
    #    text = (to_plot %>% distinct(user.id) %>% pull())[[3]],
    #    font = list(size = 16), 
    #    showarrow = FALSE,
    #    textangle=-90
    #  ),
    #  list(
    #    x = 0.75,
    #    y = 0.75,
    #    text = (to_plot %>% distinct(user.id) %>% pull())[[4]],
    #    font = list(size = 16), 
    #    showarrow = FALSE,
    #    textangle=-90
    #  )
    #)
  )
fig
```





























<!--
## About the games
### text mining su descrizioni per capire se c'e' combo "vincente"

## About user-games interactions
### rete in cui grossezza link e' ore giocate
### analisi dei giochi "centrali"

### poi collego anche i tag analisi dei tag "centrali"


### possibile recsys
```{r}
## TODO is good idea?
# Rearrange user_info: rows = users, columns=games
# consider only play

#  users_info[1:100,] %>%
#  filter(behavior.name == "play") %>%
#  distinct(user.id, game.title, value) %>%
#  spread(game.title, value)
```
-->




















































